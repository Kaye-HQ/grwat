#' Read ERA-INTERIM reanalysis NetCDF files with temperature and precipitation
#'
#' @param file_prec Precipitation NetCDF file
#' @param file_temp Temperature NetCDF file
#'
#' @return List containing time series, precipitation series, temperature series 
#'   and spatial points (sf)
#' @export
#'
#' @examples
#' \dontrun{
#' grwat::read_interim("rean/prec.nc", "rean/temp.nc")
#' }
read_interim <- function(file_prec, file_temp){
  # Read NetCDF data
  precip = nc_open(file_prec)
  temps = nc_open(file_temp)
  prate = ncvar_get(precip, precip$var$prate) * 86400
  temp = ncvar_get(temps, temps$var$air) - 273.15
  
  # Number of days and their values
  ndays.full = temps$dim$time$len
  vals.full = temps$dim$time$vals
  
  # Reconstruct spatial points
  lat = precip$dim$lat$vals
  lon = precip$dim$lon$vals
  lonidx = 1:length(lon)
  latidx = 1:length(lat)
  coords = expand.grid(lon, lat)
  idx = expand.grid(lonidx, latidx)
  data = data.frame(idx, coords)
  colnames(data) = c('nlon', 'nlat', 'lon', 'lat')
  
  pts = st_as_sf(data, coords = c("lon", "lat"), crs = 4326)
  
  return(list(vals.full = vals.full, 
              prate = prate, 
              temp = temp, 
              pts = pts)
  )
}


#' Process gauge hydrological data
#'
#' @param hdata Water discharge series. Data frame containing 4 columns: YYYY, MM, DD and water level
#' @param buffer Region to select reanalysis data
#' @param rean List. Contains three components: days series, values and location points
#'
#' @return List of two components: water level table enriched with reanalysis data
#'   and selected points
#' @export
#'
#' @examples
#' \dontrun{
#' grwat::process(hdata, rean, buffer)
#' }
process <- function(hdata, rean, buffer){
  
  # determine the first and last date
  first = hdata[1, 1:3]
  last = hdata[nrow(hdata), 1:3]
  first.date = paste(first[3], first[2], first[1], sep = "/")
  last.date = paste(last[3], last[2], last[1], sep = "/")
  
  # generate sequence of dates
  hdates = seq(as.Date(first.date), as.Date(last.date), "days")
  ndates = length(hdates)
  
  # frame for visualizing points
  frame = st_bbox(buffer) %>% as.numeric()
  frame_sf = st_bbox(buffer) %>% st_as_sfc()
  
  # Select points
  pts.selected = rean$pts[buffer, ]
  npts = nrow(pts.selected)
  
  sum.table.with.dates = NULL
  
  if (npts > 0){
    # Extract point numbers for subsetting ncdf array
    pts.numbers = pts.selected %>% select(nlon, nlat)
    st_geometry(pts.numbers) <- NULL
    
    # Extract dates for subsetting ncdf array
    datevals = lubridate::ymd(18000101) + lubridate::hours(rean$vals.full)
    flt = (datevals >= hdates[1]) & (datevals <= hdates[length(hdates)]) # !!!!
    days = (1:length(rean$vals.full))[flt]
    ndays = length(days)
    
    # Replicate position each day
    pts.positions = sapply(pts.numbers, rep.int, times = ndays)
    pts.days = rep(days, each = npts)
    
    # Generate index table for subsetting
    selection.table = data.frame(pts.positions, pts.days)
    
    # Subset data
    temp.selected = rean$temp[as.matrix(selection.table)]
    prate.selected = rean$prate[as.matrix(selection.table)]
    result = data.frame(selection.table, temp.selected, prate.selected)
    
    # calculate average temp and prate per day
    sum.table = result %>%
      group_by(pts.days) %>% 
      summarise(mean_temp = mean(temp.selected) %>% round(2),
                mean_prate = mean(prate.selected) %>% round(3))
    
    # split dates into three columns
    dates.matrix = hdates %>% 
      as.character() %>% 
      lapply(strsplit, split = '-') %>% 
      unlist() %>% 
      as.integer() %>% 
      matrix(ncol = 3, byrow = TRUE)
    
    # prepare output table
    sum.table.with.dates = data.frame(sum.table[,1], dates.matrix, sum.table[,2:3])
    colnames(sum.table.with.dates) = c("N", "Y", "M", "D", "T", "P")
  }
  
  return(list(sum.table.with.dates, pts.selected))
}

#' Process gauge directory
#'
#' @param wd Path to a directory containing water level series data and basin region
#' @param rean List with reanalysis data (generated by read_interim function)
#' @param bufsize Buffer distance to select additional points around basin region
#'
#' @return  Number of reanalysis points processed for buffered basin. All other
#'   operations are performed inside a directory
#' @export
#'
#' @examples
#' \dontrun{
#' grwat::process_gauge(wd, rean, 50000)
#' }
process_gauge <- function(wd, rean, bufsize=50000){
  
  oldwd = setwd(wd)
  on.exit(setwd(oldwd), add = TRUE)
  
  hydro.file = list.files('.','.txt')[1]
  input_name = strsplit(hydro.file, '[.]')[[1]][1]
  
  reanpts = -1
  hdata = NULL
  try(hdata <- read.csv(hydro.file, sep = ' ', header = FALSE), silent = TRUE)
  
  if(is.null(hdata)){
    warning("Failed to calculate statistics for ", wd, ". Error reading input file")
  } else {
    
    # read only first file with .shp extension
    shapes = list.files("Shape")
    flt = grep(".shp$", shapes, perl = TRUE)
    region = str_interp('Shape/${shapes[flt][1]}') %>% st_read() 
    
    # buffer region to select more points
    buffer = region %>% 
      st_transform_opt() %>% # optimal projection
      st_buffer(bufsize) %>% 
      st_transform(4326)
    
    results = grwat::process(hdata, rean, buffer) # TODO: nice processing here
    
    sum.table.with.dates = results[[1]]
    pts.selected = results[[2]]
    
    if (is.null(pts.selected)){
      warning("Failed to calculate statistics for ", gauge, ". No reanalysis data available")
    } else {
      
      reanpts = nrow(pts.selected)
      
      CairoPNG(str_interp('${wd}.png'),  
               height = 5, width = 5, 
               units = 'in', dpi = 300)
      
      par_default = par(no.readonly = TRUE)
      par(mfrow = c(1,1))
      
      
      plot(buffer %>% st_geometry(), col = rgb(1, 0, 0, 0.2), border = rgb(1, 0, 0), lwd = 0.5)
      plot(region, col = rgb(1, 0, 0, 0.5), border = rgb(1, 0, 0), add = TRUE)
      plot(rivers, col = 'steelblue4', lwd = 0.5, add = TRUE)
      plot(rivers_europe, col = 'steelblue4', lwd = 0.2, add = TRUE)
      plot(lakes, border = 'steelblue4', col = 'skyblue', lwd = 0.2, add = TRUE)
      plot(lakes_europe, border = 'steelblue4', col = 'skyblue', lwd = 0.2, add = TRUE)
      plot(ocean, border = 'steelblue4', col = 'skyblue', lwd = 0.5, add = TRUE)
      plot(rean$pts, pch = 19, col = 'gray30', cex = 0.3, add = TRUE)
      plot(pts.selected, pch = 19, col = 'black', cex = 0.7, add = TRUE)
      box(lwd = 0.2, col = 'black')
      
      par(par_default)
      
      dev.off()
      
      # write output files
      sum.table.with.dates %>% 
        select(`T`, P) %>% 
        write_delim(path = paste(input_name, "_rean.txt", sep = ""),
                    delim = " ",
                    col_names = FALSE
        )
      sum.table.with.dates %>% 
        select(D, M, Y, `T`, P) %>% 
        write_delim(path = paste(input_name, "_rean_ymd.txt", sep = ""),
                    delim = " ",
                    col_names = FALSE
        )
    }
  }
  
  return(reanpts)
}

#' Join reanalysis data based on geographic location and time
#'
#' @param wd Path to a working directory with specified structure
#' @param bufsize Size of a buffer that is used to select reanalysis data
#'   around each basin
#'
#' @return Generates water level files enriched with reanalysis data.
#'   Produces text reports on a number of a processed gauges in each basin
#' @export
#'
#' @examples
#' \dontrun{
#' grwat::process_basins(wd)
#' }
process_basins <- function(wd, bufsize=50000, clear=TRUE){
  message(wd)
  old = setwd(wd)
  on.exit(setwd(old), add = TRUE)
  
  rean = grwat::read_interim("rean/prec.nc", "rean/temp.nc")
  
  # clear previous data
  if(clear) {
    unlink('out', recursive = TRUE)
    dir.create('out')
  }
  
  file.copy('in/.', 'out', recursive = TRUE)
  
  wd = paste0(wd, 'out/')
  setwd(wd)
  
  # list basins
  basins = list.dirs(recursive = FALSE, full.names = FALSE)
  reports = vector('list', length = length(basins))
  
  i = 1
  for (basin in basins) {
    setwd(wd)
    setwd(basin)
    gauges = list.dirs(recursive = FALSE, full.names = FALSE)
    
    reanpts = vector(mode = "integer", length(gauges))
    j = 1
    
    for (gauge in gauges){
      reanpts[j] = grwat::process_gauge(gauge, rean, bufsize) # TODO: correct working directory
      
      setwd(wd)
      setwd(basin)
      j = j + 1
    }
    
    reports[[i]] = data.frame(gauge = gauges, reanpts)
    write_delim(reports[[i]], "summary.txt")
    i = i + 1
  }
  
  setwd(wd)
  
  # export large report for all basins
  ngauges = sapply(reports, nrow)
  
  report = do.call(rbind, reports) %>% 
    mutate(basin = rep(basins, ngauges)) %>% 
    select(basin, gauge, reanpts)
  
  write_delim(report, "summary.txt") 
}

#' Generate reports with detailed hydrograph analysis
#'
#' @param wd Character. A working directory with specified structure
#'
#' @return Generates a new out working directory with detailed reports
#' @export
#'
#' @examples
report <- function(wd){
  # list basins
  old = setwd(wd)
  on.exit(setwd(old), add = TRUE)
  
  basins = list.dirs(recursive = FALSE, full.names = FALSE)
  
  # Generate reports for each gauge
  for (basin in basins) {
    setwd(wd)
    setwd(basin)
    gauges = list.dirs(recursive = FALSE, full.names = FALSE)
    
    for (gauge in gauges){
      setwd(gauge)
      
      fullpath = getwd()
      
      rmarkdown::render(input = system.file('reports', 'Report.Rmd', package = 'grwat'), 
                        output_file = 'report.pdf',
                        output_dir = fullpath,
                        knit_root_dir = fullpath,
                        encoding = 'UTF-8',
                        params = list(name = gauge, namen = gauge))
      setwd(wd)
      setwd(basin)
      break
    }
    break
  } 
}